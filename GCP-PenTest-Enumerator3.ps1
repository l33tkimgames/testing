<#
.SYNOPSIS
    GCP Penetration Test Enumerator - Comprehensive GCP enumeration for penetration testing.

.DESCRIPTION
    Enumerates IAM policies, service accounts, storage buckets, compute instances, networking,
    secrets, Cloud Functions, BigQuery datasets, and more across all projects in projects.txt.
    Focuses heavily on privilege escalation pathways and misconfigurations.

    Outputs all findings to structured files for scripted post-processing.
    Generates a text-based mind map of project structure and permission relationships.

    TOOLS REQUIRED: gcloud, gsutil, bq (Google Cloud SDK on Windows / PowerShell)

.NOTES
    Author:  Penetration Tester Toolkit
    Usage:   .\GCP-PenTest-Enumerator.ps1
    Prereqs: Authenticated gcloud session, projects.txt in the same directory.
#>

# ============================================================================
# CONFIGURATION
# ============================================================================
$ErrorActionPreference = "Continue"
$Timestamp            = Get-Date -Format "yyyyMMdd_HHmmss"
$BaseOutputDir        = ".\GCP_PenTest_Output_$Timestamp"
$ProjectsFile         = ".\projects.txt"
$MindMapFile          = "$BaseOutputDir\00_MIND_MAP.txt"
$SummaryFile          = "$BaseOutputDir\00_FINDINGS_SUMMARY.txt"
$PrivEscFile          = "$BaseOutputDir\00_PRIVESC_FINDINGS.txt"
$ErrorLogFile         = "$BaseOutputDir\00_ERRORS.log"
$ManifestFile         = "$BaseOutputDir\00_MANIFEST.json"

# ---- Structured manifest for the PrivEsc Testing script ----
# This collects all discovered resources in machine-readable form so
# GCP-PrivEsc-Tester.ps1 can consume them without re-enumerating.
$Script:Manifest = @{
    generated_at     = (Get-Date -Format 'o')
    caller_account   = ""
    organizations    = @()
    projects         = @{}
    role_permissions = @{}
}

# High-risk IAM permissions that enable privilege escalation
$PrivEscPermissions = @(
    # ---- IAM Abuse ----
    "iam.serviceAccounts.actAs",
    "iam.serviceAccounts.getAccessToken",
    "iam.serviceAccounts.getOpenIdToken",
    "iam.serviceAccounts.implicitDelegation",
    "iam.serviceAccounts.signBlob",
    "iam.serviceAccounts.signJwt",
    "iam.serviceAccountKeys.create",
    "iam.roles.update",
    "resourcemanager.projects.setIamPolicy",
    "resourcemanager.folders.setIamPolicy",
    "resourcemanager.organizations.setIamPolicy",
    # ---- Compute Abuse ----
    "compute.instances.setMetadata",
    "compute.projects.setCommonInstanceMetadata",
    "compute.instances.setServiceAccount",
    "compute.instances.create",
    "compute.instances.osLogin",
    "compute.instances.osAdminLogin",
    # ---- Cloud Functions Abuse ----
    "cloudfunctions.functions.create",
    "cloudfunctions.functions.update",
    "cloudfunctions.functions.sourceCodeSet",
    # ---- Cloud Run / Build ----
    "run.services.create",
    "run.services.update",
    "cloudbuild.builds.create",
    # ---- Storage ----
    "storage.objects.create",
    "storage.objects.setIamPolicy",
    "storage.buckets.setIamPolicy",
    # ---- Secrets ----
    "secretmanager.versions.access",
    # ---- Deployment Manager ----
    "deploymentmanager.deployments.create",
    # ---- Composer / Dataflow / Dataproc ----
    "composer.environments.create",
    "dataflow.jobs.create",
    "dataproc.clusters.create",
    # ---- Org Policy ----
    "orgpolicy.policy.set",
    # ---- Service Usage ----
    "serviceusage.services.enable"
)

# Dangerous predefined roles (broad or admin-level)
$DangerousRoles = @(
    "roles/owner",
    "roles/editor",
    "roles/iam.securityAdmin",
    "roles/iam.serviceAccountAdmin",
    "roles/iam.serviceAccountUser",
    "roles/iam.serviceAccountTokenCreator",
    "roles/iam.serviceAccountKeyAdmin",
    "roles/iam.workloadIdentityUser",
    "roles/resourcemanager.projectIamAdmin",
    "roles/resourcemanager.organizationAdmin",
    "roles/resourcemanager.folderAdmin",
    "roles/cloudfunctions.admin",
    "roles/run.admin",
    "roles/compute.admin",
    "roles/compute.instanceAdmin",
    "roles/compute.instanceAdmin.v1",
    "roles/storage.admin",
    "roles/secretmanager.admin",
    "roles/cloudbuild.builds.editor",
    "roles/composer.admin",
    "roles/dataproc.admin",
    "roles/dataflow.admin",
    "roles/deploymentmanager.editor",
    "roles/orgpolicy.policyAdmin",
    "roles/serviceusage.serviceUsageAdmin"
)

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

function Write-Log {
    param([string]$Message, [string]$Level = "INFO")
    $entry = "[$(Get-Date -Format 'HH:mm:ss')] [$Level] $Message"
    Write-Host $entry -ForegroundColor $(switch ($Level) {
        "INFO"    { "Cyan" }
        "WARN"    { "Yellow" }
        "ERROR"   { "Red" }
        "PRIVESC" { "Magenta" }
        "FINDING" { "Green" }
        default   { "White" }
    })
    if ($Level -eq "ERROR") {
        Add-Content -Path $ErrorLogFile -Value $entry
    }
}

function Write-Finding {
    param(
        [string]$Category,
        [string]$Project,
        [string]$Detail,
        [string]$Severity = "MEDIUM"
    )
    $entry = @"
================================================================================
[FINDING] [$Severity] $Category
Project : $Project
Detail  : $Detail
Time    : $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
================================================================================

"@
    Add-Content -Path $SummaryFile -Value $entry
    if ($Category -match "PRIVESC|Privilege|Escalation|Dangerous Role|Service Account Key|actAs|setIamPolicy") {
        Add-Content -Path $PrivEscFile -Value $entry
    }
    Write-Log "FINDING [$Severity]: $Category in $Project" "FINDING"
}

function Run-GcloudJson {
    param([string]$Command, [string]$Description = "")
    try {
        if ($Description) { Write-Log $Description }
        $raw = Invoke-Expression "gcloud $Command --format=json 2>&1"
        $stderr = ($raw | Where-Object { $_ -is [System.Management.Automation.ErrorRecord] }) -join "`n"
        $stdout = ($raw | Where-Object { $_ -isnot [System.Management.Automation.ErrorRecord] }) -join "`n"
        if ($stderr -and $stderr -notmatch "Listed 0 items|WARNING") {
            Write-Log "stderr for [$Command]: $stderr" "WARN"
        }
        if ($stdout) {
            return $stdout | ConvertFrom-Json
        }
        return $null
    }
    catch {
        Write-Log "Failed: gcloud $Command -> $_" "ERROR"
        return $null
    }
}

function Save-Output {
    param([string]$FilePath, $Data, [switch]$Append)
    try {
        if ($null -eq $Data) {
            if (-not $Append) { Set-Content -Path $FilePath -Value "# No data returned" }
            return
        }
        $json = $Data | ConvertTo-Json -Depth 20
        if ($Append) {
            Add-Content -Path $FilePath -Value $json
        } else {
            Set-Content -Path $FilePath -Value $json
        }
    }
    catch {
        # Fallback: write raw
        if ($Append) {
            Add-Content -Path $FilePath -Value ($Data | Out-String)
        } else {
            Set-Content -Path $FilePath -Value ($Data | Out-String)
        }
    }
}

function Ensure-Dir {
    param([string]$Path)
    if (-not (Test-Path $Path)) { New-Item -ItemType Directory -Path $Path -Force | Out-Null }
}

# ============================================================================
# ROLE PERMISSION RESOLVER
# ============================================================================
# Fetches and caches the full permission list for any IAM role (predefined or
# custom).  Results are saved to _roles/ so the PrivEsc Tester can reuse them.

$Script:RolePermCache = @{}

function Resolve-RolePermissions {
    <#
    .DESCRIPTION
        Returns the full list of IAM permissions for a given role.
        Caches the result so each role is only queried once.
        Saves each role's permissions to $BaseOutputDir\_roles\<safe_name>.json
    #>
    param([string]$Role, [string]$Project = "")

    if ($Script:RolePermCache.ContainsKey($Role)) {
        return $Script:RolePermCache[$Role]
    }

    $rolesDir = "$BaseOutputDir\_roles"
    Ensure-Dir $rolesDir

    $roleDetail = $null
    if ($Role -match "^projects/") {
        # Custom project role â€” needs --project flag
        $roleDetail = Run-GcloudJson "iam roles describe $Role --project=$Project"
    } elseif ($Role -match "^organizations/") {
        $roleDetail = Run-GcloudJson "iam roles describe $Role"
    } else {
        # Predefined role (e.g. roles/owner)
        $roleDetail = Run-GcloudJson "iam roles describe $Role"
    }

    $perms = @()
    if ($roleDetail -and $roleDetail.includedPermissions) {
        $perms = @($roleDetail.includedPermissions)
    }

    $Script:RolePermCache[$Role] = $perms

    # Save to file
    $safeName = $Role -replace '[/:]','_'
    $roleFile = "$rolesDir\$safeName.json"
    $roleOutput = @{
        role              = $Role
        title             = $roleDetail.title
        description       = $roleDetail.description
        total_permissions = $perms.Count
        permissions       = $perms
        privesc_permissions = @($perms | Where-Object { $_ -in $PrivEscPermissions })
    }
    Save-Output $roleFile $roleOutput

    return $perms
}

function Get-PrivEscPermsForRole {
    <#
    .DESCRIPTION
        Returns only the privilege-escalation-relevant permissions for a role.
    #>
    param([string]$Role, [string]$Project = "")
    $allPerms = Resolve-RolePermissions -Role $Role -Project $Project
    return @($allPerms | Where-Object { $_ -in $PrivEscPermissions })
}

# ============================================================================
# MIND MAP BUILDER
# ============================================================================
$Script:MindMap = [System.Collections.ArrayList]::new()

function Add-MindMapNode {
    param([string]$Line)
    [void]$Script:MindMap.Add($Line)
}

function Save-MindMap {
    $Script:MindMap | Set-Content -Path $MindMapFile
    Write-Log "Mind map saved to $MindMapFile"
}

function Build-ProjectManifest {
    param([string]$Project, [string]$OutputDir)
    # Reads the JSON files already saved by enumeration modules and builds
    # a structured manifest entry for this project. The manifest is consumed
    # by GCP-PrivEsc-Tester.ps1 to avoid re-enumerating.

    $entry = @{
        project_id        = $Project
        service_accounts  = @()
        compute_instances = @()
        cloud_functions   = @()
        cloud_run         = @()
        storage_buckets   = @()
        secrets           = @()
        gke_clusters      = @()
        cloudsql          = @()
        bigquery_datasets = @()
        build_triggers    = @()
        custom_roles      = @()
        iam_bindings      = @()
        enabled_apis      = @()
    }

    # Service accounts
    $saFile = "$OutputDir\service_accounts\service_accounts.json"
    if (Test-Path $saFile) {
        try {
            $raw = Get-Content $saFile -Raw
            if ($raw -and $raw -ne "# No data returned") {
                $saList = $raw | ConvertFrom-Json
                foreach ($sa in $saList) {
                    $saEntry = @{
                        email      = $sa.email
                        name       = $sa.displayName
                        is_default = [bool]($sa.email -match "\d+-compute@developer|@appspot\.gserviceaccount|@cloudbuild\.gserviceaccount|@cloudservices\.gserviceaccount")
                        user_keys  = @()
                    }
                    # Check for user-managed keys
                    $keyFile = "$OutputDir\service_accounts\sa_keys_$($sa.email -replace '[^a-zA-Z0-9]','_').json"
                    if (Test-Path $keyFile) {
                        try {
                            $kr = Get-Content $keyFile -Raw
                            if ($kr -and $kr -ne "# No data returned") {
                                $saEntry.user_keys = @($kr | ConvertFrom-Json)
                            }
                        } catch {}
                    }
                    $entry.service_accounts += $saEntry
                }
            }
        } catch {}
    }

    # Compute instances
    $compFile = "$OutputDir\compute\instances.json"
    if (Test-Path $compFile) {
        try {
            $raw = Get-Content $compFile -Raw
            if ($raw -and $raw -ne "# No data returned") {
                $instList = $raw | ConvertFrom-Json
                foreach ($inst in $instList) {
                    $entry.compute_instances += @{
                        name    = $inst.name
                        zone    = ($inst.zone -split '/')[-1]
                        status  = $inst.status
                        sa      = if ($inst.serviceAccounts) { $inst.serviceAccounts[0].email } else { $null }
                        scopes  = if ($inst.serviceAccounts) { $inst.serviceAccounts[0].scopes } else { @() }
                    }
                }
            }
        } catch {}
    }

    # Cloud Functions
    $fnFile = "$OutputDir\cloud_functions\functions.json"
    if (Test-Path $fnFile) {
        try {
            $raw = Get-Content $fnFile -Raw
            if ($raw -and $raw -ne "# No data returned") {
                $fnList = $raw | ConvertFrom-Json
                foreach ($fn in $fnList) {
                    $entry.cloud_functions += @{
                        name     = $fn.name
                        short    = ($fn.name -split '/')[-1]
                        region   = ($fn.name -split '/')[3]
                        runtime  = $fn.runtime
                        sa       = $fn.serviceAccountEmail
                        trigger  = if ($fn.httpsTrigger) { $fn.httpsTrigger.url } else { "event" }
                        ingress  = $fn.ingressSettings
                    }
                }
            }
        } catch {}
    }

    # Cloud Run
    $runFile = "$OutputDir\cloud_run\services.json"
    if (Test-Path $runFile) {
        try {
            $raw = Get-Content $runFile -Raw
            if ($raw -and $raw -ne "# No data returned") {
                $runList = $raw | ConvertFrom-Json
                foreach ($svc in $runList) {
                    $entry.cloud_run += @{
                        name   = $svc.metadata.name
                        region = $svc.metadata.labels.'cloud.googleapis.com/location'
                        url    = $svc.status.url
                        sa     = $svc.spec.template.spec.serviceAccountName
                    }
                }
            }
        } catch {}
    }

    # Secrets
    $secFile = "$OutputDir\secrets\secrets.json"
    if (Test-Path $secFile) {
        try {
            $raw = Get-Content $secFile -Raw
            if ($raw -and $raw -ne "# No data returned") {
                $secList = $raw | ConvertFrom-Json
                foreach ($s in $secList) {
                    $entry.secrets += @{ name = ($s.name -split '/')[-1]; full_name = $s.name }
                }
            }
        } catch {}
    }

    # GKE
    $gkeFile = "$OutputDir\gke\clusters.json"
    if (Test-Path $gkeFile) {
        try {
            $raw = Get-Content $gkeFile -Raw
            if ($raw -and $raw -ne "# No data returned") {
                $gkeList = $raw | ConvertFrom-Json
                foreach ($c in $gkeList) {
                    $entry.gke_clusters += @{
                        name     = $c.name
                        location = $c.location
                        node_sa  = $c.nodeConfig.serviceAccount
                    }
                }
            }
        } catch {}
    }

    # Cloud SQL
    $sqlFile = "$OutputDir\cloudsql\sql_instances.json"
    if (Test-Path $sqlFile) {
        try {
            $raw = Get-Content $sqlFile -Raw
            if ($raw -and $raw -ne "# No data returned") {
                $sqlList = $raw | ConvertFrom-Json
                foreach ($db in $sqlList) {
                    $entry.cloudsql += @{ name = $db.name; version = $db.databaseVersion }
                }
            }
        } catch {}
    }

    # Build triggers
    $btFile = "$OutputDir\cloudbuild\build_triggers.json"
    if (Test-Path $btFile) {
        try {
            $raw = Get-Content $btFile -Raw
            if ($raw -and $raw -ne "# No data returned") {
                $btList = $raw | ConvertFrom-Json
                foreach ($t in $btList) {
                    $entry.build_triggers += @{
                        name = $t.name
                        id   = $t.id
                        sa   = $t.serviceAccount
                    }
                }
            }
        } catch {}
    }

    # Custom roles
    $crFile = "$OutputDir\iam\custom_roles.json"
    if (Test-Path $crFile) {
        try {
            $raw = Get-Content $crFile -Raw
            if ($raw -and $raw -ne "# No data returned") {
                $crList = $raw | ConvertFrom-Json
                foreach ($cr in $crList) {
                    $entry.custom_roles += @{ name = $cr.name; title = $cr.title; stage = $cr.stage }
                }
            }
        } catch {}
    }

    # IAM bindings
    $iamFile = "$OutputDir\iam\project_iam_policy.json"
    if (Test-Path $iamFile) {
        try {
            $raw = Get-Content $iamFile -Raw
            if ($raw -and $raw -ne "# No data returned") {
                $iamPol = $raw | ConvertFrom-Json
                if ($iamPol.bindings) {
                    foreach ($b in $iamPol.bindings) {
                        $entry.iam_bindings += @{ role = $b.role; members = @($b.members) }
                    }
                }
            }
        } catch {}
    }

    # Enabled APIs
    $apiFile = "$OutputDir\services\enabled_services.json"
    if (Test-Path $apiFile) {
        try {
            $raw = Get-Content $apiFile -Raw
            if ($raw -and $raw -ne "# No data returned") {
                $apiList = $raw | ConvertFrom-Json
                foreach ($a in $apiList) {
                    $entry.enabled_apis += $a.config.name
                }
            }
        } catch {}
    }

    # Buckets (stored as plain text list)
    $bucketFile = "$OutputDir\storage\buckets_list.json"
    if (Test-Path $bucketFile) {
        try {
            $raw = Get-Content $bucketFile -Raw
            if ($raw -and $raw -ne "# No data returned") {
                $bl = $raw | ConvertFrom-Json
                foreach ($b in $bl) {
                    if ($b -match "^gs://") {
                        $entry.storage_buckets += ($b -replace 'gs://','' -replace '/$','')
                    }
                }
            }
        } catch {}
    }

    # BigQuery datasets
    $bqFile = "$OutputDir\bigquery\datasets.json"
    if (Test-Path $bqFile) {
        try {
            $raw = Get-Content $bqFile -Raw
            if ($raw -and $raw -ne "# No data returned") {
                $bqList = $raw | ConvertFrom-Json
                foreach ($ds in $bqList) {
                    $entry.bigquery_datasets += $ds.datasetReference.datasetId
                }
            }
        } catch {}
    }

    $Script:Manifest.projects[$Project] = $entry
}

function Save-Manifest {
    # Embed the resolved role permissions into the manifest
    $rolePermsForManifest = @{}
    foreach ($role in $Script:RolePermCache.Keys) {
        $allPerms = $Script:RolePermCache[$role]
        $rolePermsForManifest[$role] = @{
            total_permissions   = $allPerms.Count
            permissions         = $allPerms
            privesc_permissions = @($allPerms | Where-Object { $_ -in $PrivEscPermissions })
        }
    }
    $Script:Manifest.role_permissions = $rolePermsForManifest
    $Script:Manifest | ConvertTo-Json -Depth 20 | Set-Content -Path $ManifestFile
    Write-Log "Manifest saved to $ManifestFile (includes $($rolePermsForManifest.Count) resolved roles)"
}

# ============================================================================
# ENUMERATION MODULES
# ============================================================================

# ---------- 0. Caller Identity & Org Info ----------
function Enumerate-CallerIdentity {
    Write-Log "=== Enumerating Caller Identity ===" "INFO"
    $dir = "$BaseOutputDir\_identity"
    Ensure-Dir $dir

    # Who am I?
    $authList = Run-GcloudJson "auth list" "Listing authenticated accounts"
    Save-Output "$dir\auth_list.json" $authList

    # Active account details
    $account = (gcloud config get-value account 2>$null)
    $projectDefault = (gcloud config get-value project 2>$null)
    $configInfo = @{
        active_account  = $account
        default_project = $projectDefault
    }
    Save-Output "$dir\active_config.json" $configInfo
    $Script:Manifest.caller_account = $account

    Add-MindMapNode "GCP PENETRATION TEST MIND MAP"
    Add-MindMapNode "================================"
    Add-MindMapNode ""
    Add-MindMapNode "[IDENTITY]"
    Add-MindMapNode "  Active Account : $account"
    Add-MindMapNode "  Default Project: $projectDefault"
    Add-MindMapNode ""

    # Try org-level enumeration
    Write-Log "Attempting organization enumeration..."
    $orgs = Run-GcloudJson "organizations list" "Listing organizations"
    Save-Output "$dir\organizations.json" $orgs
    if ($orgs) {
        foreach ($org in $orgs) {
            Add-MindMapNode "[ORGANIZATION] $($org.displayName) (ID: $($org.name))"

            # Org IAM policy (may fail without permissions)
            $orgId = $org.name -replace 'organizations/', ''
            $orgPolicy = Run-GcloudJson "organizations get-iam-policy $orgId" "Fetching org IAM policy for $orgId"
            Save-Output "$dir\org_iam_policy_$orgId.json" $orgPolicy
            if ($orgPolicy) {
                Analyze-IamPolicy -Policy $orgPolicy -ResourceName "Organization:$orgId" -Project "ORG-LEVEL"
            }
        }
    }

    # Folders
    $folders = Run-GcloudJson "resource-manager folders list --organization=$(($orgs | Select-Object -First 1).name -replace 'organizations/','')" "Listing folders"
    Save-Output "$dir\folders.json" $folders
    if ($folders) {
        Add-MindMapNode ""
        Add-MindMapNode "[FOLDERS]"
        foreach ($f in $folders) {
            Add-MindMapNode "  +-- $($f.displayName) ($($f.name))"
        }
    }

    Add-MindMapNode ""
    Add-MindMapNode "========================================================"
    Add-MindMapNode "PROJECTS ($($projects.Count) total)"
    Add-MindMapNode "========================================================"
    Add-MindMapNode ""
}

# ---------- 1. IAM Policy Analysis ----------
function Analyze-IamPolicy {
    param($Policy, [string]$ResourceName, [string]$Project)
    if (-not $Policy -or -not $Policy.bindings) { return }

    foreach ($binding in $Policy.bindings) {
        $role = $binding.role

        # Check for dangerous roles
        if ($role -in $DangerousRoles) {
            $privEscPerms = Get-PrivEscPermsForRole -Role $role -Project $Project
            $allPerms     = Resolve-RolePermissions -Role $role -Project $Project
            $permSummary  = if ($privEscPerms.Count -gt 0) {
                "PrivEsc Permissions ($($privEscPerms.Count)): $($privEscPerms -join ', ')"
            } else {
                "Total Permissions: $($allPerms.Count) (no direct privesc permissions, but broad access)"
            }
            foreach ($member in $binding.members) {
                Write-Finding -Category "PRIVESC: Dangerous Role Assignment" `
                    -Project $Project `
                    -Detail "Resource=$ResourceName | Role=$role | Member=$member | $permSummary" `
                    -Severity "HIGH"
            }
        }

        # Flag allUsers / allAuthenticatedUsers
        foreach ($member in $binding.members) {
            if ($member -in @("allUsers", "allAuthenticatedUsers")) {
                $pubPerms = Get-PrivEscPermsForRole -Role $role -Project $Project
                $pubPermStr = if ($pubPerms.Count -gt 0) { " | PrivEsc Permissions: $($pubPerms -join ', ')" } else { "" }
                Write-Finding -Category "PUBLIC ACCESS: $ResourceName" `
                    -Project $Project `
                    -Detail "Role=$role granted to $member$pubPermStr" `
                    -Severity "CRITICAL"
            }

            # Flag user accounts with SA-related roles
            if ($member -match "^user:" -and $role -match "serviceAccount") {
                $saRolePerms = Get-PrivEscPermsForRole -Role $role -Project $Project
                $saRolePermStr = if ($saRolePerms.Count -gt 0) { " | PrivEsc Permissions: $($saRolePerms -join ', ')" } else { "" }
                Write-Finding -Category "PRIVESC: User with SA Role" `
                    -Project $Project `
                    -Detail "Resource=$ResourceName | Role=$role | Member=$member$saRolePermStr" `
                    -Severity "HIGH"
            }
        }
    }
}

# ---------- 2. Project-Level IAM ----------
function Enumerate-ProjectIAM {
    param([string]$Project, [string]$OutputDir)
    $dir = "$OutputDir\iam"
    Ensure-Dir $dir

    Write-Log "  [IAM] Fetching project IAM policy..."
    $policy = Run-GcloudJson "projects get-iam-policy $Project"
    Save-Output "$dir\project_iam_policy.json" $policy

    Add-MindMapNode "  [IAM POLICY]"

    if ($policy -and $policy.bindings) {
        Analyze-IamPolicy -Policy $policy -ResourceName "Project:$Project" -Project $Project

        # Build role->members map for mind map
        $roleMap = @{}
        foreach ($binding in $policy.bindings) {
            $roleMap[$binding.role] = $binding.members
        }
        foreach ($role in ($roleMap.Keys | Sort-Object)) {
            $memberCount = $roleMap[$role].Count
            $isDangerous = if ($role -in $DangerousRoles) { " ** DANGEROUS **" } else { "" }
            Add-MindMapNode "    +-- $role ($memberCount members)$isDangerous"
            # If dangerous, list the privesc-relevant permissions under the role
            if ($role -in $DangerousRoles) {
                $privEscPerms = Get-PrivEscPermsForRole -Role $role -Project $Project
                $allPerms     = Resolve-RolePermissions -Role $role -Project $Project
                if ($privEscPerms.Count -gt 0) {
                    Add-MindMapNode "        [!] PrivEsc Permissions ($($privEscPerms.Count) of $($allPerms.Count) total):"
                    foreach ($p in $privEscPerms) {
                        Add-MindMapNode "            -> $p"
                    }
                } else {
                    Add-MindMapNode "        [!] $($allPerms.Count) total permissions (broad access, no single privesc perm)"
                }
            }
            foreach ($m in $roleMap[$role]) {
                $flag = ""
                if ($m -in @("allUsers","allAuthenticatedUsers")) { $flag = " !! PUBLIC !!" }
                Add-MindMapNode "        +-- $m$flag"
            }
        }
    }

    # Custom roles
    Write-Log "  [IAM] Checking custom roles..."
    $customRoles = Run-GcloudJson "iam roles list --project=$Project"
    Save-Output "$dir\custom_roles.json" $customRoles
    if ($customRoles) {
        Add-MindMapNode "    [CUSTOM ROLES]"
        foreach ($cr in $customRoles) {
            Add-MindMapNode "      +-- $($cr.name) ($($cr.title))"
            # Get details for each custom role to check permissions
            $roleName = $cr.name
            $roleDetail = Run-GcloudJson "iam roles describe $roleName --project=$Project"
            Save-Output "$dir\custom_role_$($cr.title -replace '[^a-zA-Z0-9]','_').json" $roleDetail
            if ($roleDetail -and $roleDetail.includedPermissions) {
                foreach ($perm in $roleDetail.includedPermissions) {
                    if ($perm -in $PrivEscPermissions) {
                        Write-Finding -Category "PRIVESC: Custom Role with Dangerous Permission" `
                            -Project $Project `
                            -Detail "Role=$roleName | Permission=$perm" `
                            -Severity "HIGH"
                        Add-MindMapNode "          !! PRIVESC PERM: $perm"
                    }
                }
            }
        }
    }
}

# ---------- 3. Service Accounts ----------
function Enumerate-ServiceAccounts {
    param([string]$Project, [string]$OutputDir)
    $dir = "$OutputDir\service_accounts"
    Ensure-Dir $dir

    Write-Log "  [SA] Enumerating service accounts..."
    $sas = Run-GcloudJson "iam service-accounts list --project=$Project"
    Save-Output "$dir\service_accounts.json" $sas

    Add-MindMapNode "  [SERVICE ACCOUNTS]"

    if (-not $sas) { Add-MindMapNode "    (none found)"; return }

    foreach ($sa in $sas) {
        $saEmail = $sa.email
        $saName  = $sa.displayName
        $isDefault = $saEmail -match "\d+-compute@developer\.gserviceaccount\.com|@appspot\.gserviceaccount\.com"
        $defaultFlag = if ($isDefault) { " (DEFAULT SA)" } else { "" }
        Add-MindMapNode "    +-- $saEmail$defaultFlag"

        # SA IAM policy (who can impersonate this SA?)
        $saPolicy = Run-GcloudJson "iam service-accounts get-iam-policy $saEmail --project=$Project"
        Save-Output "$dir\sa_policy_$($saEmail -replace '[^a-zA-Z0-9]','_').json" $saPolicy
        if ($saPolicy -and $saPolicy.bindings) {
            Analyze-IamPolicy -Policy $saPolicy -ResourceName "ServiceAccount:$saEmail" -Project $Project
            foreach ($binding in $saPolicy.bindings) {
                Add-MindMapNode "        Policy: $($binding.role) -> $($binding.members -join ', ')"
                # Check for impersonation paths
                if ($binding.role -match "iam.serviceAccountUser|iam.serviceAccountTokenCreator|iam.workloadIdentityUser") {
                    $impersonPerms = Get-PrivEscPermsForRole -Role $binding.role -Project $Project
                    $impersonPermStr = if ($impersonPerms.Count -gt 0) { " | PrivEsc Permissions: $($impersonPerms -join ', ')" } else { "" }
                    foreach ($m in $binding.members) {
                        Write-Finding -Category "PRIVESC: SA Impersonation Path" `
                            -Project $Project `
                            -Detail "SA=$saEmail | Role=$($binding.role) | Granted to=$m$impersonPermStr" `
                            -Severity "HIGH"
                        Add-MindMapNode "        !! IMPERSONATION PATH: $m can impersonate via $($binding.role)"
                        if ($impersonPerms.Count -gt 0) {
                            foreach ($ip in $impersonPerms) {
                                Add-MindMapNode "            -> $ip"
                            }
                        }
                    }
                }
            }
        }

        # SA Keys (external keys = high risk)
        $saKeys = Run-GcloudJson "iam service-accounts keys list --iam-account=$saEmail --project=$Project --managed-by=user"
        Save-Output "$dir\sa_keys_$($saEmail -replace '[^a-zA-Z0-9]','_').json" $saKeys
        if ($saKeys) {
            foreach ($key in $saKeys) {
                Write-Finding -Category "PRIVESC: User-Managed SA Key Exists" `
                    -Project $Project `
                    -Detail "SA=$saEmail | KeyID=$($key.name) | ValidAfter=$($key.validAfterTime) | ValidBefore=$($key.validBeforeTime)" `
                    -Severity "HIGH"
                Add-MindMapNode "        !! USER KEY: $($key.name -split '/' | Select-Object -Last 1)"
            }
        }
    }
}

# ---------- 4. Compute Instances ----------
function Enumerate-Compute {
    param([string]$Project, [string]$OutputDir)
    $dir = "$OutputDir\compute"
    Ensure-Dir $dir

    Write-Log "  [COMPUTE] Enumerating instances..."
    $instances = Run-GcloudJson "compute instances list --project=$Project"
    Save-Output "$dir\instances.json" $instances

    Add-MindMapNode "  [COMPUTE INSTANCES]"

    if (-not $instances) { Add-MindMapNode "    (none found)"; return }

    foreach ($inst in $instances) {
        $name = $inst.name
        $zone = ($inst.zone -split '/')[-1]
        $status = $inst.status
        $saScopes = ""

        Add-MindMapNode "    +-- $name ($zone) [$status]"

        # Check service account and scopes
        if ($inst.serviceAccounts) {
            foreach ($sa in $inst.serviceAccounts) {
                $saEmail = $sa.email
                $scopes = $sa.scopes -join ", "
                Add-MindMapNode "        SA: $saEmail"
                Add-MindMapNode "        Scopes: $scopes"

                # cloud-platform scope = full API access
                if ($scopes -match "cloud-platform") {
                    Write-Finding -Category "PRIVESC: Instance with cloud-platform Scope" `
                        -Project $Project `
                        -Detail "Instance=$name | Zone=$zone | SA=$saEmail | Full cloud-platform scope grants broad API access" `
                        -Severity "HIGH"
                    Add-MindMapNode "        !! FULL cloud-platform SCOPE"
                }

                # Default compute SA with broad scopes
                if ($saEmail -match "\d+-compute@developer\.gserviceaccount\.com") {
                    $editorPrivEsc = Get-PrivEscPermsForRole -Role "roles/editor" -Project $Project
                    $editorPermStr = if ($editorPrivEsc.Count -gt 0) { " | roles/editor PrivEsc Permissions ($($editorPrivEsc.Count)): $($editorPrivEsc -join ', ')" } else { "" }
                    Write-Finding -Category "PRIVESC: Default Compute SA in Use" `
                        -Project $Project `
                        -Detail "Instance=$name uses default compute SA=$saEmail (typically has roles/editor)$editorPermStr" `
                        -Severity "MEDIUM"
                    Add-MindMapNode "        !! DEFAULT COMPUTE SA (typically roles/editor)"
                }
            }
        }

        # External IP = network exposure
        if ($inst.networkInterfaces) {
            foreach ($nic in $inst.networkInterfaces) {
                if ($nic.accessConfigs) {
                    foreach ($ac in $nic.accessConfigs) {
                        if ($ac.natIP) {
                            Add-MindMapNode "        External IP: $($ac.natIP)"
                            Write-Finding -Category "EXPOSURE: Instance with External IP" `
                                -Project $Project `
                                -Detail "Instance=$name | Zone=$zone | ExternalIP=$($ac.natIP)" `
                                -Severity "LOW"
                        }
                    }
                }
                # Check network/subnetwork for shared VPC
                Add-MindMapNode "        Network: $($nic.network -split '/' | Select-Object -Last 1)"
            }
        }

        # Check metadata for startup scripts (may contain secrets)
        if ($inst.metadata -and $inst.metadata.items) {
            foreach ($item in $inst.metadata.items) {
                if ($item.key -match "startup-script|ssh-keys|user-data") {
                    Write-Finding -Category "RECON: Instance Metadata of Interest" `
                        -Project $Project `
                        -Detail "Instance=$name | MetadataKey=$($item.key) (may contain secrets/scripts)" `
                        -Severity "MEDIUM"
                    Add-MindMapNode "        !! Metadata key: $($item.key)"
                }
            }
            Save-Output "$dir\instance_metadata_$name.json" $inst.metadata
        }

        # Check if serial port output is accessible (info leak)
        # Just note it; fetching all serial output would be noisy
        Add-MindMapNode "        (serial port output available via: gcloud compute instances get-serial-port-output $name --zone=$zone --project=$Project)"
    }

    # Project-wide metadata (SSH keys, startup scripts)
    Write-Log "  [COMPUTE] Checking project-wide metadata..."
    $projMetadata = Run-GcloudJson "compute project-info describe --project=$Project"
    Save-Output "$dir\project_metadata.json" $projMetadata
    if ($projMetadata -and $projMetadata.commonInstanceMetadata -and $projMetadata.commonInstanceMetadata.items) {
        foreach ($item in $projMetadata.commonInstanceMetadata.items) {
            if ($item.key -match "ssh-keys|startup-script|enable-oslogin") {
                Add-MindMapNode "    [PROJECT METADATA] $($item.key) is set"
                if ($item.key -eq "enable-oslogin" -and $item.value -eq "FALSE") {
                    Write-Finding -Category "PRIVESC: OS Login Disabled Project-Wide" `
                        -Project $Project `
                        -Detail "OS Login disabled -> SSH keys in metadata -> potential lateral movement" `
                        -Severity "MEDIUM"
                }
                if ($item.key -eq "ssh-keys") {
                    $keyCount = ($item.value -split "`n").Count
                    Write-Finding -Category "RECON: Project-Wide SSH Keys Found" `
                        -Project $Project `
                        -Detail "$keyCount SSH key(s) in project metadata" `
                        -Severity "MEDIUM"
                }
            }
        }
    }
}

# ---------- 5. Storage Buckets ----------
function Enumerate-Storage {
    param([string]$Project, [string]$OutputDir)
    $dir = "$OutputDir\storage"
    Ensure-Dir $dir

    Write-Log "  [STORAGE] Enumerating buckets..."

    Add-MindMapNode "  [STORAGE BUCKETS]"

    try {
        $bucketsRaw = gsutil ls -p $Project 2>&1
        $buckets = $bucketsRaw | Where-Object { $_ -match "^gs://" }
        Save-Output "$dir\buckets_list.json" @($buckets)
    }
    catch {
        Write-Log "  Failed to list buckets: $_" "ERROR"
        $buckets = @()
    }

    if (-not $buckets -or $buckets.Count -eq 0) {
        Add-MindMapNode "    (none found)"
        return
    }

    foreach ($bucket in $buckets) {
        $bucketName = $bucket -replace 'gs://','' -replace '/$',''
        Add-MindMapNode "    +-- $bucketName"

        # Bucket IAM policy
        try {
            $bucketIamRaw = gsutil iam get "gs://$bucketName" 2>&1
            $bucketIamText = ($bucketIamRaw | Where-Object { $_ -isnot [System.Management.Automation.ErrorRecord] }) -join "`n"
            Set-Content -Path "$dir\bucket_iam_$bucketName.json" -Value $bucketIamText

            if ($bucketIamText -match "allUsers|allAuthenticatedUsers") {
                Write-Finding -Category "PUBLIC ACCESS: Storage Bucket" `
                    -Project $Project `
                    -Detail "Bucket=$bucketName has public access (allUsers/allAuthenticatedUsers)" `
                    -Severity "CRITICAL"
                Add-MindMapNode "      !! PUBLIC ACCESS"
            }
        }
        catch {
            Write-Log "  Failed to get IAM for $bucketName : $_" "WARN"
        }

        # Bucket ACLs (legacy)
        try {
            $aclRaw = gsutil acl get "gs://$bucketName" 2>&1
            $aclText = ($aclRaw | Where-Object { $_ -isnot [System.Management.Automation.ErrorRecord] }) -join "`n"
            Set-Content -Path "$dir\bucket_acl_$bucketName.json" -Value $aclText
        } catch {}

        # Check for uniform bucket-level access
        try {
            $bucketInfoRaw = gsutil uniformbucketlevelaccess get "gs://$bucketName" 2>&1
            $bucketInfoText = ($bucketInfoRaw | Where-Object { $_ -isnot [System.Management.Automation.ErrorRecord] }) -join "`n"
            Add-Content -Path "$dir\bucket_uniform_access_$bucketName.txt" -Value $bucketInfoText
            if ($bucketInfoText -match "Enabled:\s*False") {
                Write-Finding -Category "CONFIG: Uniform Bucket Access Disabled" `
                    -Project $Project `
                    -Detail "Bucket=$bucketName uses legacy ACLs (more complex, easier to misconfigure)" `
                    -Severity "LOW"
            }
        } catch {}

        # List top-level objects (limit to avoid huge output)
        try {
            $objectsRaw = gsutil ls -l "gs://$bucketName/" 2>&1 | Select-Object -First 50
            $objectsText = ($objectsRaw | Where-Object { $_ -isnot [System.Management.Automation.ErrorRecord] }) -join "`n"
            Set-Content -Path "$dir\bucket_objects_$bucketName.txt" -Value $objectsText

            # Look for interesting file patterns
            $interestingPatterns = @("\.env", "\.key", "\.pem", "\.p12", "\.pfx", "\.json", "credential", "secret", "password", "token", "backup", "\.sql", "\.dump", "\.bak", "terraform\.tfstate")
            foreach ($pattern in $interestingPatterns) {
                if ($objectsText -match $pattern) {
                    Write-Finding -Category "RECON: Interesting File in Bucket" `
                        -Project $Project `
                        -Detail "Bucket=$bucketName | Pattern=$pattern found in object listing" `
                        -Severity "MEDIUM"
                    Add-MindMapNode "      !! INTERESTING FILE PATTERN: $pattern"
                }
            }
        }
        catch {}
    }
}

# ---------- 6. Cloud Functions ----------
function Enumerate-CloudFunctions {
    param([string]$Project, [string]$OutputDir)
    $dir = "$OutputDir\cloud_functions"
    Ensure-Dir $dir

    Write-Log "  [FUNCTIONS] Enumerating Cloud Functions..."
    $functions = Run-GcloudJson "functions list --project=$Project"
    Save-Output "$dir\functions.json" $functions

    Add-MindMapNode "  [CLOUD FUNCTIONS]"

    if (-not $functions) { Add-MindMapNode "    (none found)"; return }

    foreach ($fn in $functions) {
        $fnName = $fn.name -split '/' | Select-Object -Last 1
        $runtime = $fn.runtime
        $saEmail = $fn.serviceAccountEmail
        $trigger = if ($fn.httpsTrigger) { "HTTPS: $($fn.httpsTrigger.url)" } elseif ($fn.eventTrigger) { "Event: $($fn.eventTrigger.eventType)" } else { "Unknown" }
        $ingress = $fn.ingressSettings

        Add-MindMapNode "    +-- $fnName ($runtime)"
        Add-MindMapNode "        SA: $saEmail"
        Add-MindMapNode "        Trigger: $trigger"
        Add-MindMapNode "        Ingress: $ingress"

        # Functions with ALLOW_ALL ingress + HTTPS trigger = potentially exposed
        if ($ingress -eq "ALLOW_ALL" -and $fn.httpsTrigger) {
            Write-Finding -Category "EXPOSURE: Cloud Function Publicly Accessible" `
                -Project $Project `
                -Detail "Function=$fnName | URL=$($fn.httpsTrigger.url) | Ingress=ALLOW_ALL" `
                -Severity "MEDIUM"
            Add-MindMapNode "        !! PUBLICLY ACCESSIBLE"
        }

        # Check IAM for unauthenticated invocation
        $fnIam = Run-GcloudJson "functions get-iam-policy $fnName --project=$Project --region=$(($fn.name -split '/')[3])"
        Save-Output "$dir\fn_iam_$fnName.json" $fnIam
        if ($fnIam -and $fnIam.bindings) {
            foreach ($binding in $fnIam.bindings) {
                if ($binding.members -contains "allUsers" -or $binding.members -contains "allAuthenticatedUsers") {
                    Write-Finding -Category "PRIVESC: Unauthenticated Cloud Function Invocation" `
                        -Project $Project `
                        -Detail "Function=$fnName allows unauthenticated invocation -> SA=$saEmail context" `
                        -Severity "CRITICAL"
                    Add-MindMapNode "        !! UNAUTHENTICATED INVOCATION"
                }
            }
        }

        # Function environment variables (may contain secrets)
        if ($fn.environmentVariables) {
            Save-Output "$dir\fn_env_$fnName.json" $fn.environmentVariables
            $envKeys = ($fn.environmentVariables | Get-Member -MemberType NoteProperty).Name
            foreach ($key in $envKeys) {
                if ($key -match "SECRET|KEY|TOKEN|PASSWORD|CREDENTIAL|API_KEY|PRIVATE") {
                    Write-Finding -Category "RECON: Function Env Var with Sensitive Name" `
                        -Project $Project `
                        -Detail "Function=$fnName | EnvVar=$key" `
                        -Severity "HIGH"
                    Add-MindMapNode "        !! SENSITIVE ENV VAR: $key"
                }
            }
        }
    }
}

# ---------- 7. Cloud Run ----------
function Enumerate-CloudRun {
    param([string]$Project, [string]$OutputDir)
    $dir = "$OutputDir\cloud_run"
    Ensure-Dir $dir

    Write-Log "  [CLOUD RUN] Enumerating services..."
    $services = Run-GcloudJson "run services list --project=$Project --platform=managed"
    Save-Output "$dir\services.json" $services

    Add-MindMapNode "  [CLOUD RUN]"

    if (-not $services) { Add-MindMapNode "    (none found)"; return }

    foreach ($svc in $services) {
        $svcName = $svc.metadata.name
        $url = $svc.status.url
        $saEmail = $svc.spec.template.spec.serviceAccountName

        Add-MindMapNode "    +-- $svcName"
        Add-MindMapNode "        URL: $url"
        Add-MindMapNode "        SA: $saEmail"

        # Check for unauthenticated access
        $svcIam = Run-GcloudJson "run services get-iam-policy $svcName --project=$Project --platform=managed --region=$(($svc.metadata.labels.'cloud.googleapis.com/location'))"
        Save-Output "$dir\run_iam_$svcName.json" $svcIam
        if ($svcIam -and $svcIam.bindings) {
            foreach ($binding in $svcIam.bindings) {
                if (($binding.members -contains "allUsers" -or $binding.members -contains "allAuthenticatedUsers") -and $binding.role -eq "roles/run.invoker") {
                    Write-Finding -Category "EXPOSURE: Unauthenticated Cloud Run Service" `
                        -Project $Project `
                        -Detail "Service=$svcName | URL=$url | Public invocation enabled" `
                        -Severity "HIGH"
                    Add-MindMapNode "        !! UNAUTHENTICATED ACCESS"
                }
            }
        }
    }
}

# ---------- 8. Secret Manager ----------
function Enumerate-Secrets {
    param([string]$Project, [string]$OutputDir)
    $dir = "$OutputDir\secrets"
    Ensure-Dir $dir

    Write-Log "  [SECRETS] Enumerating Secret Manager secrets..."
    $secrets = Run-GcloudJson "secrets list --project=$Project"
    Save-Output "$dir\secrets.json" $secrets

    Add-MindMapNode "  [SECRET MANAGER]"

    if (-not $secrets) { Add-MindMapNode "    (none found)"; return }

    foreach ($secret in $secrets) {
        $secretName = $secret.name -split '/' | Select-Object -Last 1
        Add-MindMapNode "    +-- $secretName"

        # Check IAM on the secret
        $secretIam = Run-GcloudJson "secrets get-iam-policy $secretName --project=$Project"
        Save-Output "$dir\secret_iam_$secretName.json" $secretIam
        if ($secretIam -and $secretIam.bindings) {
            foreach ($binding in $secretIam.bindings) {
                foreach ($member in $binding.members) {
                    if ($member -in @("allUsers","allAuthenticatedUsers")) {
                        Write-Finding -Category "CRITICAL: Public Secret Access" `
                            -Project $Project `
                            -Detail "Secret=$secretName accessible by $member" `
                            -Severity "CRITICAL"
                        Add-MindMapNode "      !! PUBLIC ACCESS"
                    }
                }
                Add-MindMapNode "      $($binding.role) -> $($binding.members -join ', ')"
            }
        }

        # Attempt to access latest version (the pentester's test)
        try {
            $secretValue = gcloud secrets versions access latest --secret=$secretName --project=$Project 2>&1
            $isError = $secretValue | Where-Object { $_ -is [System.Management.Automation.ErrorRecord] }
            if (-not $isError) {
                Write-Finding -Category "PRIVESC: Secret Value Accessible" `
                    -Project $Project `
                    -Detail "Secret=$secretName -> current identity can read the secret value!" `
                    -Severity "CRITICAL"
                Add-MindMapNode "      !! READABLE BY CURRENT IDENTITY"
                # Save value (truncated for safety)
                $truncated = if ($secretValue.Length -gt 100) { $secretValue.Substring(0,100) + "...[TRUNCATED]" } else { $secretValue }
                Save-Output "$dir\secret_value_$secretName.txt" $truncated
            }
        }
        catch {}
    }
}

# ---------- 9. BigQuery ----------
function Enumerate-BigQuery {
    param([string]$Project, [string]$OutputDir)
    $dir = "$OutputDir\bigquery"
    Ensure-Dir $dir

    Write-Log "  [BQ] Enumerating BigQuery datasets..."

    Add-MindMapNode "  [BIGQUERY]"

    try {
        $datasetsRaw = bq ls --project_id=$Project --format=json 2>&1
        $datasetsText = ($datasetsRaw | Where-Object { $_ -isnot [System.Management.Automation.ErrorRecord] }) -join "`n"
        if ($datasetsText -and $datasetsText -ne "[]") {
            $datasets = $datasetsText | ConvertFrom-Json
            Save-Output "$dir\datasets.json" $datasets

            foreach ($ds in $datasets) {
                $dsId = $ds.datasetReference.datasetId
                Add-MindMapNode "    +-- $dsId"

                # Dataset ACLs
                try {
                    $dsInfoRaw = bq show --format=json "${Project}:${dsId}" 2>&1
                    $dsInfoText = ($dsInfoRaw | Where-Object { $_ -isnot [System.Management.Automation.ErrorRecord] }) -join "`n"
                    $dsInfo = $dsInfoText | ConvertFrom-Json
                    Save-Output "$dir\dataset_$dsId.json" $dsInfo

                    if ($dsInfo.access) {
                        foreach ($acl in $dsInfo.access) {
                            if ($acl.specialGroup -eq "allAuthenticatedUsers" -or $acl.iamMember -match "allUsers") {
                                Write-Finding -Category "PUBLIC ACCESS: BigQuery Dataset" `
                                    -Project $Project `
                                    -Detail "Dataset=$dsId has public access" `
                                    -Severity "CRITICAL"
                                Add-MindMapNode "      !! PUBLIC ACCESS"
                            }
                        }
                    }

                    # List tables
                    $tablesRaw = bq ls --format=json "${Project}:${dsId}" 2>&1
                    $tablesText = ($tablesRaw | Where-Object { $_ -isnot [System.Management.Automation.ErrorRecord] }) -join "`n"
                    if ($tablesText -and $tablesText -ne "[]") {
                        $tables = $tablesText | ConvertFrom-Json
                        Save-Output "$dir\tables_$dsId.json" $tables
                        foreach ($tbl in $tables) {
                            Add-MindMapNode "      +-- $($tbl.tableReference.tableId) ($($tbl.type))"
                        }
                    }
                }
                catch {
                    Write-Log "  Failed to inspect dataset $dsId : $_" "WARN"
                }
            }
        } else {
            Add-MindMapNode "    (none found)"
        }
    }
    catch {
        Write-Log "  BigQuery enumeration failed: $_" "ERROR"
        Add-MindMapNode "    (error / not enabled)"
    }
}

# ---------- 10. Networking ----------
function Enumerate-Networking {
    param([string]$Project, [string]$OutputDir)
    $dir = "$OutputDir\networking"
    Ensure-Dir $dir

    Write-Log "  [NET] Enumerating firewall rules..."
    $firewalls = Run-GcloudJson "compute firewall-rules list --project=$Project"
    Save-Output "$dir\firewall_rules.json" $firewalls

    Add-MindMapNode "  [NETWORKING]"

    if ($firewalls) {
        Add-MindMapNode "    [FIREWALL RULES]"
        foreach ($fw in $firewalls) {
            $fwName = $fw.name
            $direction = $fw.direction
            $action = if ($fw.allowed) { "ALLOW" } else { "DENY" }
            $sourceRanges = $fw.sourceRanges -join ", "
            $allowed = ($fw.allowed | ForEach-Object { "$($_.IPProtocol):$($_.ports -join ',')" }) -join "; "

            Add-MindMapNode "      +-- $fwName ($direction $action)"

            # 0.0.0.0/0 ingress = high risk
            if ($direction -eq "INGRESS" -and $sourceRanges -match "0\.0\.0\.0/0") {
                Write-Finding -Category "EXPOSURE: Firewall Open to Internet" `
                    -Project $Project `
                    -Detail "Rule=$fwName | Direction=INGRESS | Source=0.0.0.0/0 | Allowed=$allowed" `
                    -Severity "HIGH"
                Add-MindMapNode "        !! OPEN TO 0.0.0.0/0: $allowed"
            }
        }
    }

    # VPC Networks
    $networks = Run-GcloudJson "compute networks list --project=$Project"
    Save-Output "$dir\networks.json" $networks
    if ($networks) {
        Add-MindMapNode "    [VPC NETWORKS]"
        foreach ($net in $networks) {
            Add-MindMapNode "      +-- $($net.name) (mode: $($net.x_gcloud_mode))"
        }
    }

    # Subnets
    $subnets = Run-GcloudJson "compute networks subnets list --project=$Project"
    Save-Output "$dir\subnets.json" $subnets

    # External IPs
    $addresses = Run-GcloudJson "compute addresses list --project=$Project"
    Save-Output "$dir\external_addresses.json" $addresses
    if ($addresses) {
        Add-MindMapNode "    [EXTERNAL IPS]"
        foreach ($addr in $addresses) {
            Add-MindMapNode "      +-- $($addr.address) ($($addr.name)) [$($addr.status)]"
        }
    }
}

# ---------- 11. Cloud SQL ----------
function Enumerate-CloudSQL {
    param([string]$Project, [string]$OutputDir)
    $dir = "$OutputDir\cloudsql"
    Ensure-Dir $dir

    Write-Log "  [SQL] Enumerating Cloud SQL instances..."
    $sqlInstances = Run-GcloudJson "sql instances list --project=$Project"
    Save-Output "$dir\sql_instances.json" $sqlInstances

    Add-MindMapNode "  [CLOUD SQL]"

    if (-not $sqlInstances) { Add-MindMapNode "    (none found)"; return }

    foreach ($db in $sqlInstances) {
        $dbName = $db.name
        $dbType = $db.databaseVersion
        $publicIp = ($db.ipAddresses | Where-Object { $_.type -eq "PRIMARY" }).ipAddress

        Add-MindMapNode "    +-- $dbName ($dbType)"

        if ($publicIp) {
            Add-MindMapNode "        Public IP: $publicIp"
            Write-Finding -Category "EXPOSURE: Cloud SQL with Public IP" `
                -Project $Project `
                -Detail "Instance=$dbName | Type=$dbType | PublicIP=$publicIp" `
                -Severity "HIGH"
        }

        # Check authorized networks
        if ($db.settings.ipConfiguration.authorizedNetworks) {
            foreach ($authNet in $db.settings.ipConfiguration.authorizedNetworks) {
                if ($authNet.value -eq "0.0.0.0/0") {
                    Write-Finding -Category "CRITICAL: Cloud SQL Open to Internet" `
                        -Project $Project `
                        -Detail "Instance=$dbName allows connections from 0.0.0.0/0" `
                        -Severity "CRITICAL"
                    Add-MindMapNode "        !! OPEN TO 0.0.0.0/0"
                }
                Add-MindMapNode "        Authorized: $($authNet.value) ($($authNet.name))"
            }
        }

        # SSL enforcement
        if ($db.settings.ipConfiguration.requireSsl -ne $true) {
            Write-Finding -Category "CONFIG: Cloud SQL SSL Not Required" `
                -Project $Project `
                -Detail "Instance=$dbName does not require SSL for connections" `
                -Severity "MEDIUM"
            Add-MindMapNode "        !! SSL NOT REQUIRED"
        }
    }
}

# ---------- 12. GKE Clusters ----------
function Enumerate-GKE {
    param([string]$Project, [string]$OutputDir)
    $dir = "$OutputDir\gke"
    Ensure-Dir $dir

    Write-Log "  [GKE] Enumerating Kubernetes clusters..."
    $clusters = Run-GcloudJson "container clusters list --project=$Project"
    Save-Output "$dir\clusters.json" $clusters

    Add-MindMapNode "  [GKE CLUSTERS]"

    if (-not $clusters) { Add-MindMapNode "    (none found)"; return }

    foreach ($cluster in $clusters) {
        $cName = $cluster.name
        $location = $cluster.location
        $masterAuth = $cluster.masterAuth

        Add-MindMapNode "    +-- $cName ($location)"

        # Legacy ABAC enabled
        if ($cluster.legacyAbac.enabled -eq $true) {
            Write-Finding -Category "PRIVESC: GKE Legacy ABAC Enabled" `
                -Project $Project `
                -Detail "Cluster=$cName has legacy ABAC enabled -> any authenticated user can do anything" `
                -Severity "CRITICAL"
            Add-MindMapNode "        !! LEGACY ABAC ENABLED"
        }

        # Basic auth enabled (deprecated but may exist)
        if ($masterAuth.username) {
            Write-Finding -Category "PRIVESC: GKE Basic Auth Enabled" `
                -Project $Project `
                -Detail "Cluster=$cName has basic authentication enabled (username: $($masterAuth.username))" `
                -Severity "CRITICAL"
            Add-MindMapNode "        !! BASIC AUTH ENABLED"
        }

        # Client certificate
        if ($masterAuth.clientCertificate) {
            Write-Finding -Category "CONFIG: GKE Client Certificate Issued" `
                -Project $Project `
                -Detail "Cluster=$cName has client certificate auth configured" `
                -Severity "MEDIUM"
        }

        # Network policy
        if (-not $cluster.networkPolicy -or $cluster.networkPolicy.enabled -ne $true) {
            Add-MindMapNode "        Network Policy: DISABLED"
        }

        # Private cluster
        if ($cluster.privateClusterConfig) {
            Add-MindMapNode "        Private Cluster: YES"
        } else {
            Add-MindMapNode "        Private Cluster: NO (public endpoint)"
            Write-Finding -Category "EXPOSURE: GKE Public Cluster Endpoint" `
                -Project $Project `
                -Detail "Cluster=$cName API server is publicly accessible" `
                -Severity "MEDIUM"
        }

        # Node SA
        if ($cluster.nodeConfig.serviceAccount) {
            $nodeSA = $cluster.nodeConfig.serviceAccount
            Add-MindMapNode "        Node SA: $nodeSA"
            if ($nodeSA -eq "default") {
                    $editorPrivEsc = Get-PrivEscPermsForRole -Role "roles/editor" -Project $Project
                    $editorPermStr = if ($editorPrivEsc.Count -gt 0) { " | roles/editor PrivEsc Permissions ($($editorPrivEsc.Count)): $($editorPrivEsc -join ', ')" } else { "" }
                    Write-Finding -Category "PRIVESC: GKE Nodes Using Default SA" `
                        -Project $Project `
                        -Detail "Cluster=$cName nodes use default compute SA (typically has roles/editor)$editorPermStr" `
                        -Severity "HIGH"
                    Add-MindMapNode "        !! DEFAULT SA ON NODES"
                }
        }
    }
}

# ---------- 13. Enabled APIs / Services ----------
function Enumerate-Services {
    param([string]$Project, [string]$OutputDir)
    $dir = "$OutputDir\services"
    Ensure-Dir $dir

    Write-Log "  [SERVICES] Listing enabled APIs..."
    $services = Run-GcloudJson "services list --project=$Project --enabled"
    Save-Output "$dir\enabled_services.json" $services

    Add-MindMapNode "  [ENABLED APIS] ($( if($services) { $services.Count } else { 0 } ) services)"

    # Flag risky APIs that expand attack surface
    $riskyAPIs = @(
        "deploymentmanager.googleapis.com",
        "cloudfunctions.googleapis.com",
        "run.googleapis.com",
        "cloudbuild.googleapis.com",
        "composer.googleapis.com",
        "dataflow.googleapis.com",
        "dataproc.googleapis.com",
        "container.googleapis.com",
        "compute.googleapis.com",
        "admin.googleapis.com",
        "cloudresourcemanager.googleapis.com"
    )

    if ($services) {
        foreach ($svc in $services) {
            $svcName = $svc.config.name
            if ($svcName -in $riskyAPIs) {
                Add-MindMapNode "    +-- $svcName [ATTACK SURFACE]"
            }
        }
    }
}

# ---------- 14. Logging & Monitoring Gaps ----------
function Enumerate-LoggingGaps {
    param([string]$Project, [string]$OutputDir)
    $dir = "$OutputDir\logging"
    Ensure-Dir $dir

    Write-Log "  [LOGGING] Checking audit log configuration..."
    $auditConfig = Run-GcloudJson "projects get-iam-policy $Project --flatten=auditConfigs"
    Save-Output "$dir\audit_config.json" $auditConfig

    # Log sinks
    $sinks = Run-GcloudJson "logging sinks list --project=$Project"
    Save-Output "$dir\log_sinks.json" $sinks

    Add-MindMapNode "  [LOGGING/MONITORING]"
    if ($sinks) {
        foreach ($sink in $sinks) {
            Add-MindMapNode "    +-- Sink: $($sink.name) -> $($sink.destination)"
        }
    } else {
        Add-MindMapNode "    (no custom log sinks)"
        Write-Finding -Category "CONFIG: No Custom Log Sinks" `
            -Project $Project `
            -Detail "No custom log sinks configured -> limited log retention/export" `
            -Severity "LOW"
    }
}

# ---------- 15. Cloud Build (CI/CD Abuse) ----------
function Enumerate-CloudBuild {
    param([string]$Project, [string]$OutputDir)
    $dir = "$OutputDir\cloudbuild"
    Ensure-Dir $dir

    Write-Log "  [BUILD] Enumerating Cloud Build triggers..."
    $triggers = Run-GcloudJson "builds triggers list --project=$Project"
    Save-Output "$dir\build_triggers.json" $triggers

    Add-MindMapNode "  [CLOUD BUILD]"

    if (-not $triggers) { Add-MindMapNode "    (no triggers)"; return }

    foreach ($trigger in $triggers) {
        $tName = $trigger.name
        $tSA = $trigger.serviceAccount

        Add-MindMapNode "    +-- Trigger: $tName"
        if ($tSA) {
            Add-MindMapNode "        SA: $tSA"
        }

        # Check if trigger uses the default Cloud Build SA (has broad permissions)
        if (-not $tSA) {
            $editorPrivEsc = Get-PrivEscPermsForRole -Role "roles/editor" -Project $Project
            $editorPermStr = if ($editorPrivEsc.Count -gt 0) { " | roles/editor PrivEsc Permissions ($($editorPrivEsc.Count)): $($editorPrivEsc -join ', ')" } else { "" }
            Write-Finding -Category "PRIVESC: Cloud Build Trigger Uses Default SA" `
                -Project $Project `
                -Detail "Trigger=$tName uses default Cloud Build SA (has roles/editor + iam.serviceAccounts.actAs on all project SAs)$editorPermStr" `
                -Severity "HIGH"
            Add-MindMapNode "        !! DEFAULT CLOUD BUILD SA (roles/editor + actAs)"
        }

        # Check connected repositories
        if ($trigger.github) {
            Add-MindMapNode "        Repo: GitHub $($trigger.github.owner)/$($trigger.github.name)"
        }
        if ($trigger.triggerTemplate) {
            Add-MindMapNode "        Repo: CSR $($trigger.triggerTemplate.repoName)"
        }
    }
}

# ---------- 16. KMS (Encryption Keys) ----------
function Enumerate-KMS {
    param([string]$Project, [string]$OutputDir)
    $dir = "$OutputDir\kms"
    Ensure-Dir $dir

    Write-Log "  [KMS] Enumerating keyrings..."

    Add-MindMapNode "  [KMS]"

    # KMS requires listing locations first; enumerate common ones
    $locations = @("global","us","us-central1","us-east1","us-west1","europe-west1","asia-east1")
    $allKeyrings = @()

    foreach ($loc in $locations) {
        $keyrings = Run-GcloudJson "kms keyrings list --location=$loc --project=$Project"
        if ($keyrings) {
            $allKeyrings += $keyrings
            foreach ($kr in $keyrings) {
                $krName = $kr.name -split '/' | Select-Object -Last 1
                Add-MindMapNode "    +-- Keyring: $krName ($loc)"

                # List keys in keyring
                $keys = Run-GcloudJson "kms keys list --keyring=$krName --location=$loc --project=$Project"
                Save-Output "$dir\keys_${krName}_${loc}.json" $keys
                if ($keys) {
                    foreach ($k in $keys) {
                        $kName = $k.name -split '/' | Select-Object -Last 1
                        Add-MindMapNode "      +-- Key: $kName ($($k.purpose))"

                        # Check key IAM
                        $keyIam = Run-GcloudJson "kms keys get-iam-policy $kName --keyring=$krName --location=$loc --project=$Project"
                        Save-Output "$dir\key_iam_${kName}.json" $keyIam
                        if ($keyIam -and $keyIam.bindings) {
                            foreach ($binding in $keyIam.bindings) {
                                if ($binding.members -contains "allUsers" -or $binding.members -contains "allAuthenticatedUsers") {
                                    Write-Finding -Category "CRITICAL: KMS Key Public Access" `
                                        -Project $Project `
                                        -Detail "Key=$kName in $krName has public access" `
                                        -Severity "CRITICAL"
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    Save-Output "$dir\all_keyrings.json" $allKeyrings
    if ($allKeyrings.Count -eq 0) { Add-MindMapNode "    (none found in common locations)" }
}

# ============================================================================
# MAIN EXECUTION
# ============================================================================

# Create output structure
Write-Host ""
Write-Host "================================================================" -ForegroundColor White
Write-Host "  GCP PENETRATION TEST ENUMERATOR" -ForegroundColor Green
Write-Host "  Output: $BaseOutputDir" -ForegroundColor White
Write-Host "================================================================" -ForegroundColor White
Write-Host ""

Ensure-Dir $BaseOutputDir

# Initialize summary files
Set-Content -Path $SummaryFile -Value "GCP PenTest Findings Summary - $(Get-Date)`n"
Set-Content -Path $PrivEscFile -Value "GCP Privilege Escalation Findings - $(Get-Date)`n"
Set-Content -Path $ErrorLogFile -Value "Error Log - $(Get-Date)`n"

# Validate projects file
if (-not (Test-Path $ProjectsFile)) {
    Write-Log "ERROR: $ProjectsFile not found! Place it in the script directory." "ERROR"
    exit 1
}

$projects = Get-Content -Path $ProjectsFile | Where-Object { $_ -match '\S' } | ForEach-Object { $_.Trim() }
Write-Log "Loaded $($projects.Count) projects from $ProjectsFile"

# ---------- Phase 0: Identity & Org ----------
Enumerate-CallerIdentity

# ---------- Phase 1: Per-Project Enumeration ----------
$projectIndex = 0
foreach ($project in $projects) {
    $projectIndex++
    $pct = [math]::Round(($projectIndex / $projects.Count) * 100)

    Write-Host ""
    Write-Host "================================================================" -ForegroundColor Yellow
    Write-Host "  [$projectIndex/$($projects.Count)] ($pct%) PROJECT: $project" -ForegroundColor Yellow
    Write-Host "================================================================" -ForegroundColor Yellow

    $projDir = "$BaseOutputDir\$project"
    Ensure-Dir $projDir

    Add-MindMapNode ""
    Add-MindMapNode "========================================================"
    Add-MindMapNode "PROJECT: $project"
    Add-MindMapNode "========================================================"

    # Set project context for gcloud
    # (We pass --project= to most commands, but set it as default too)
    gcloud config set project $project 2>$null

    # Run all enumeration modules
    Enumerate-ProjectIAM       -Project $project -OutputDir $projDir
    Enumerate-ServiceAccounts  -Project $project -OutputDir $projDir
    Enumerate-Services         -Project $project -OutputDir $projDir
    Enumerate-Compute          -Project $project -OutputDir $projDir
    Enumerate-Storage          -Project $project -OutputDir $projDir
    Enumerate-CloudFunctions   -Project $project -OutputDir $projDir
    Enumerate-CloudRun         -Project $project -OutputDir $projDir
    Enumerate-Secrets          -Project $project -OutputDir $projDir
    Enumerate-BigQuery         -Project $project -OutputDir $projDir
    Enumerate-Networking       -Project $project -OutputDir $projDir
    Enumerate-CloudSQL         -Project $project -OutputDir $projDir
    Enumerate-GKE              -Project $project -OutputDir $projDir
    Enumerate-CloudBuild       -Project $project -OutputDir $projDir
    Enumerate-KMS              -Project $project -OutputDir $projDir
    Enumerate-LoggingGaps      -Project $project -OutputDir $projDir

    # Build structured manifest entry for this project
    Build-ProjectManifest -Project $project -OutputDir $projDir
}

# ---------- Phase 2: Save Mind Map ----------
Add-MindMapNode ""
Add-MindMapNode "========================================================"
Add-MindMapNode "PRIVILEGE ESCALATION QUICK REFERENCE"
Add-MindMapNode "========================================================"
Add-MindMapNode ""
Add-MindMapNode "Common GCP PrivEsc Paths (check findings above):"
Add-MindMapNode "  1. iam.serviceAccountKeys.create  -> Create key for any SA you have access to"
Add-MindMapNode "  2. iam.serviceAccounts.actAs       -> Impersonate SA (attach to resource)"
Add-MindMapNode "  3. iam.serviceAccounts.getAccessToken -> Get OAuth token for SA"
Add-MindMapNode "  4. iam.serviceAccounts.signBlob    -> Sign as SA (forge tokens)"
Add-MindMapNode "  5. resourcemanager.projects.setIamPolicy -> Grant yourself any role"
Add-MindMapNode "  6. compute.instances.setMetadata   -> Inject SSH keys / startup scripts"
Add-MindMapNode "  7. compute.instances.create + actAs -> Spin up VM as privileged SA"
Add-MindMapNode "  8. cloudfunctions.functions.create + actAs -> Deploy function as SA"
Add-MindMapNode "  9. run.services.create + actAs     -> Deploy Cloud Run as SA"
Add-MindMapNode " 10. cloudbuild.builds.create        -> Abuse Cloud Build SA (Editor-like)"
Add-MindMapNode " 11. deploymentmanager.deployments.create -> Deploy as DM SA (Owner)"
Add-MindMapNode " 12. composer.environments.create    -> Airflow -> GKE -> node SA"
Add-MindMapNode " 13. orgpolicy.policy.set            -> Remove org constraints"
Add-MindMapNode " 14. secretmanager.versions.access   -> Read secrets for lateral movement"
Add-MindMapNode " 15. Default Compute SA + cloud-platform scope -> Broad API access from VM"
Add-MindMapNode ""
Add-MindMapNode "Chain Pattern: User -> SA impersonation -> Resource creation with SA -> Higher privilege"
Add-MindMapNode ""

Save-MindMap
Save-Manifest

# ---------- Phase 3: Summary Report ----------
Write-Host ""
Write-Host "================================================================" -ForegroundColor Green
Write-Host "  ENUMERATION COMPLETE" -ForegroundColor Green
Write-Host "================================================================" -ForegroundColor Green
Write-Host ""
Write-Host "  Output Directory : $BaseOutputDir" -ForegroundColor White
Write-Host "  Mind Map         : $MindMapFile" -ForegroundColor White
Write-Host "  All Findings     : $SummaryFile" -ForegroundColor White
Write-Host "  PrivEsc Findings : $PrivEscFile" -ForegroundColor White
Write-Host "  Manifest (JSON)  : $ManifestFile" -ForegroundColor White
Write-Host "  Error Log        : $ErrorLogFile" -ForegroundColor White
Write-Host ""

# Count findings by severity
$summaryContent = Get-Content $SummaryFile -Raw
$critCount = ([regex]::Matches($summaryContent, '\[CRITICAL\]')).Count
$highCount = ([regex]::Matches($summaryContent, '\[HIGH\]')).Count
$medCount  = ([regex]::Matches($summaryContent, '\[MEDIUM\]')).Count
$lowCount  = ([regex]::Matches($summaryContent, '\[LOW\]')).Count

Write-Host "  Findings Summary:" -ForegroundColor White
Write-Host "    CRITICAL : $critCount" -ForegroundColor Red
Write-Host "    HIGH     : $highCount" -ForegroundColor Magenta
Write-Host "    MEDIUM   : $medCount" -ForegroundColor Yellow
Write-Host "    LOW      : $lowCount" -ForegroundColor Cyan
Write-Host ""
Write-Host "  Tip: Review $PrivEscFile first for quick wins." -ForegroundColor Green
Write-Host "  Tip: Use 'Select-String' to search across all JSON outputs." -ForegroundColor Green
Write-Host "    Example: Get-ChildItem $BaseOutputDir -Recurse -Filter *.json | Select-String 'allUsers'" -ForegroundColor Gray
Write-Host ""
